# -*- coding: utf-8 -*-
"""CropYield.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A0BkMKcQ-3M6-hPEZ5koL2uEy8m8JTBV
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
import os
pd.set_option('display.max_columns',200)

from google.colab import files
upload = files.upload()

df = pd.read_csv("crop_yield.csv")
print(df.head())
print("Dataset shape:", df.shape)
print(df.info())
print(df.dtypes)

dups = df.duplicated()
print("number of duplicated rows = %d" % dups.sum())
df.plot(figsize=(12,6))
plt.show()

numeric_cols = ['Area', 'Production', 'Annual_Rainfall', 'Fertilizer', 'Pesticide', 'Yield']
for i, col in enumerate(numeric_cols, 1):
    plt.subplot(2, 3, i)
    sns.boxplot(y=df[col])
    plt.title(f'Boxplot of {col}')
    plt.ylabel('')
plt.tight_layout()
plt.show()
def remove_outlier(col):
    Q1, Q3 = col.quantile([0.25, 0.75])
    IQR = Q3 - Q1
    lower_range = Q1 - (1.5 * IQR)
    upper_range = Q3 + (1.5 * IQR)
    mask = (col >= lower_range) & (col <= upper_range)
    df.drop(df[~mask].index, inplace=True)

numeric_cols = ['Area', 'Production', 'Annual_Rainfall', 'Fertilizer', 'Pesticide', 'Yield']
for i, col in enumerate(numeric_cols, 1):
    plt.subplot(2, 3, i)
    sns.boxplot(y=df[col])
    plt.title(f'Boxplot of {col}')
    plt.ylabel('')
plt.tight_layout()
plt.show()

df.plot(figsize=(12,6))
plt.show()

print(df.isnull().sum())
print(df.describe(include='all'))
print(df.isnull().sum().sum())

import pandas as pd

def encode_categoricals(df: pd.DataFrame) -> pd.DataFrame:
    return pd.get_dummies(df, columns=df.select_dtypes(include=["object", "category"]).columns, drop_first=True)

def plot_heatmap(df: pd.DataFrame, target_column: str) -> None:

    numeric_df = df.select_dtypes(include=["number"])
    if target_column not in numeric_df.columns:
        raise ValueError(f"Target column {target_column!r} is missing from the numeric dataframe")

    correlation_matrix = numeric_df.corr()
    plt.figure(figsize=(12, 8))
    sns.heatmap(correlation_matrix, annot=True, cmap="coolwarm", center=0,
                square=True, fmt=".2f", linewidths=0.5)
    plt.title("Correlation Heatmap of Numerical Variables", fontsize=16, fontweight="bold")
    plt.tight_layout()
    plt.show()
    target_corr = correlation_matrix[target_column].sort_values(ascending=False)
    print(target_corr)

X = df.drop('Yield', axis=1).copy()
categorical_cols = X.select_dtypes(include=['object']).columns.tolist()

label_encoders = {}
for col in categorical_cols:
    le = LabelEncoder()
    X[col] = le.fit_transform(X[col])
    label_encoders[col] = le


y = df['Yield']
print(f"Features shape (X): {X.shape}")
print(f"Target shape (y): {y.shape}")
print(f"Total features available: {X.shape[1]}")

print(X.columns[:10])
X_train, X_test, Y_train, Y_test = train_test_split(X,y,test_size=0.2,random_state=42)
print(X_train.shape)
print(X_test.shape)


rf = RandomForestRegressor(random_state=42)
lr = LinearRegression()

rf.fit(X_train, Y_train)
lr.fit(X_train, Y_train)

rf_pred = rf.predict(X_test)
lr_pred = lr.predict(X_test)

print("Random Forest:", mean_absolute_error(Y_test, rf_pred))
print("Linear Regression:", mean_absolute_error(Y_test, lr_pred))

rf_mae = mean_absolute_error(Y_test, rf_pred)
rf_mse = mean_squared_error(Y_test, rf_pred)
rf_rmse = np.sqrt(rf_mse)
rf_r2 = r2_score(Y_test, rf_pred)

lr_mae = mean_absolute_error(Y_test,lr_pred)
lr_mse = mean_squared_error(Y_test, lr_pred)
lr_rmse = np.sqrt(lr_mse)
lr_r2 = r2_score(Y_test,lr_pred)

print(f"MAE: {rf_mae:.4f}, MSE: {rf_mse:.4f}, RMSE: {rf_rmse:.4f}, R²: {rf_r2:.4f}")
print(f"MAE: {lr_mae:.4f}, MSE: {lr_mse:.4f}, RMSE: {lr_rmse:.4f}, R²: {lr_r2:.4f}")


feature_importances = rf.feature_importances_
feature_names = X.columns

importance_df = pd.DataFrame({
    'feature': feature_names,
    'importance': feature_importances
}).sort_values('importance', ascending=False)

plt.figure(figsize=(10, 8))
plt.barh(importance_df['feature'][:20], importance_df['importance'][:20])
plt.xlabel('Importance')
plt.title('Top 20 Feature Importances (Random Forest)')
plt.gca().invert_yaxis()
plt.tight_layout()
plt.show()
plt.figure(figsize=(12, 5))
plt.show()

plt.subplot(1, 2, 1)
rf_residuals = Y_test - rf_pred
plt.scatter(rf_pred, rf_residuals, alpha=0.5)
plt.axhline(y=0, color='r', linestyle='--')
plt.xlabel('Predicted Values')
plt.ylabel('Residuals')
plt.title('Random Forest Residual Plot')
plt.show()

plt.subplot(1, 2, 2)
lr_residuals = Y_test - lr_pred
plt.scatter(lr_pred, lr_residuals, alpha=0.5)
plt.axhline(y=0, color='r', linestyle='--')
plt.xlabel('Predicted Values')
plt.ylabel('Residuals')
plt.title('Linear Regression Residual Plot')
plt.tight_layout()

plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.scatter(Y_test, rf_pred, alpha=0.5)
plt.plot([Y_test.min(), Y_test.max()], [Y_test.min(), Y_test.max()], 'r--')
plt.xlabel('Actual Values')
plt.ylabel('Predicted Values')
plt.title('Random Forest: Actual vs Predicted')
plt.show()

plt.subplot(1, 2, 2)
plt.scatter(Y_test, lr_pred, alpha=0.5)
plt.plot([Y_test.min(), Y_test.max()], [Y_test.min(), Y_test.max()], 'r--')
plt.xlabel('Actual Values')
plt.ylabel('Predicted Values')
plt.title('Linear Regression: Actual vs Predicted')

plt.tight_layout()
plt.show()

comparison_df = pd.DataFrame({
    'Model': ['Random Forest', 'Linear Regression'],
    'Test MAE': [rf_mae, lr_mae],
    'Test R²': [rf_r2, lr_r2],
    'CV MAE': [rf_cv_mae, lr_cv_mae]
})
print(comparison_df)
plt.show()

def predict_yield_and_recommend(model, input_data, crop_name, threshold=0.7):
  prediction = model.predict(input_data)[0]
  yield_threshold = np.percentile(y, 70)
  recommendation = "Yes" if prediction >= yield_threshold else "No"
  return prediction, recommendation
sample_crop = "Rice"
sample_state = "Uttar Pradesh"
sample_data = X[X['Crop'] == label_encoders['Crop'].transform([sample_crop])[0]].mean().to_frame().T
if sample_data.isna().any().any():
    sample_data = X.mean().to_frame().T
    sample_data = sample_data.reindex(columns=X.columns, fill_value=0)

rf_prediction, rf_recommendation = predict_yield_and_recommend(rf, sample_data, sample_crop)
lr_prediction, lr_recommendation = predict_yield_and_recommend(lr, sample_data, sample_crop)
print("\n" + "="*60)
print("CROP YIELD PREDICTION RESULTS")
print("="*60)
print(f"Crop: {sample_crop}")
print(f"State: {sample_state}")
print(f"\nRandom Forest Prediction: {rf_prediction:.2f} kg/ha")
print(f"Recommendation: {rf_recommendation} (Is this crop suitable?)")
print(f"\nLinear Regression Prediction: {lr_prediction:.2f} kg/ha")
print(f"Recommendation: {lr_recommendation} (Is this crop suitable?)")
plt.figure(figsize=(14, 10))
plt.subplot(2, 2, 1)
best_model = rf if rf_r2 > lr_r2 else lr
best_pred = rf_pred if rf_r2 > lr_r2 else lr_pred
best_name = "Random Forest" if rf_r2 > lr_r2 else "Linear Regression"
plt.scatter(Y_test, best_pred, alpha=0.6)
plt.plot([Y_test.min(), Y_test.max()], [Y_test.min(), Y_test.max()], 'r--', lw=2)
plt.xlabel('Actual Yield (kg/ha)')
plt.ylabel('Predicted Yield (kg/ha)')
plt.title(f'{best_name}: Actual vs Predicted Yield\nR² = {best_model.score(X_test, Y_test):.3f}')
plt.grid(True, alpha=0.3)

plt.subplot(2, 2, 2)
top_features = importance_df.head(10)
plt.barh(top_features['feature'], top_features['importance'])
plt.xlabel('Importance')
plt.title('Top 10 Important Features for Yield Prediction')
plt.gca().invert_yaxis()

plt.subplot(2, 2, 3)
models = ['Random Forest', 'Linear Regression']
mae_values = [rf_mae, lr_mae]
r2_values = [rf_r2, lr_r2]

x = np.arange(len(models))
width = 0.35

fig, ax = plt.subplots()
rects1 = ax.bar(x - width/2, mae_values, width, label='MAE')
rects2 = ax.bar(x + width/2, r2_values, width, label='R²')

ax.set_ylabel('Scores')
ax.set_title('Model Performance Comparison')
ax.set_xticks(x)
ax.set_xticklabels(models)
ax.legend()

plt.subplot(2, 2, 4)
top_crops = df['Crop'].value_counts().head(10).index
crop_yield_means = df[df['Crop'].isin(top_crops)].groupby('Crop')['Yield'].mean().sort_values(ascending=False)
plt.barh(range(len(crop_yield_means)), crop_yield_means.values)
plt.yticks(range(len(crop_yield_means)), crop_yield_means.index)
plt.xlabel('Average Yield (kg/ha)')
plt.title('Average Yield by Crop Type')
plt.gca().invert_yaxis()

plt.tight_layout()
plt.show()

try:
    user_crop = input("Enter a crop name (or press Enter to use default): ").strip()
    if not user_crop:
        user_crop = sample_crop
        print(f"Using default crop: {user_crop}")
    if user_crop in label_encoders['Crop'].classes_:
        # Find the state with highest yield for this crop
        crop_data = df[df['Crop'] == user_crop]
    if not crop_data.empty:
            best_state = crop_data.groupby('State')['Yield'].mean().idxmax()
            print(f"Recommended state for {user_crop}: {best_state}")
    user_input = X[X['Crop'] == label_encoders['Crop'].transform([user_crop])[0]].mean().to_frame().T
    user_input = user_input.reindex(columns=X.columns, fill_value=0)
    prediction, recommendation = predict_yield_and_recommend(rf, user_input, user_crop)
except Exception as e:
    print("Error in processing your input. Please try again.")

crop_type = input("Enter Crop Type (e.g., Rice, Wheat, Maize): ").strip()
farm_area = float(input("Enter Farm Area (hectares): "))
location = input("Enter Location/State: ").strip()
growing_season = input("Enter Growing Season (Kharif/Rabi/Whole Year): ").strip()
expected_rainfall = float(input("Enter Expected Rainfall (mm): "))
avg_temperature = float(input("Enter Average Temperature (°C): "))
try:
        input_data = X.mean().to_frame().T
        input_data['Area'] = farm_area
        if crop_type in label_encoders['Crop'].classes_:
            input_data['Crop'] = label_encoders['Crop'].transform([crop_type])[0]
        if location in label_encoders['State'].classes_:
            input_data['State'] = label_encoders['State'].transform([location])[0]
        else:
            # If state not found, use most common state for this crop or default
            if crop_type in df['Crop'].values:
                common_state = df[df['Crop'] == crop_type]['State'].mode()
                if len(common_state) > 0:
                    input_data['State'] = label_encoders['State'].transform([common_state[0]])[0]
        input_data['Annual_Rainfall'] = expected_rainfall
        temp_factor = avg_temperature
        input_data['Fertilizer'] = input_data['Fertilizer'] * temp_factor
        predicted_yield, recommendation = predict_yield_and_recommend(rf, input_data, crop_type)
        if crop_type in df['Crop'].values:
          crop_avg_yield = df[df['Crop'] == crop_type]['Yield'].mean()
          yield_ratio = predicted_yield / crop_avg_yield
          confidence = min(100, max(0, yield_ratio * 80))
        else:
            confidence = 70
        estimated_production = farm_area * predicted_yield
        market_value = (estimated_production / 1000) * 300
        recommendations = []
        if recommendation == "Yes":
            recommendations.append("✓ This crop is well-suited for your conditions")
            recommendations.append("✓ Expected yield is above average for this crop type")
        else:
            recommendations.append("⚠ Consider alternative crops better suited to your conditions")
            recommendations.append("⚠ Yield expectations are below average for this crop type")
        if growing_season.lower() in ['kharif', 'monsoon']:
            recommendations.append("✓ Kharif season is optimal for most crops")
        elif growing_season.lower() == 'rabi':
            recommendations.append("✓ Rabi season requires careful water management")
        if expected_rainfall < 500:
            recommendations.append("⚠ Low rainfall expected - consider irrigation options")
        elif expected_rainfall > 1500:
            recommendations.append("⚠ High rainfall expected - ensure proper drainage")
        if avg_temperature < 15:
            recommendations.append("⚠ Low temperatures may affect growth - consider greenhouse")
        elif avg_temperature > 35:
            recommendations.append("⚠ High temperatures may stress plants - provide shade")
        print("\n" + "="*60)
        print("PREDICTION RESULTS")
        print("="*60)
        print(f"Crop: {crop_type}")
        print(f"Location: {location}")
        print(f"Season: {growing_season}")
        print(f"Farm Area: {farm_area} hectares")
        print(f"\nExpected Yield: {predicted_yield:.2f} kg/ha")
        print(f"Total Production: {estimated_production:.2f} kg")
        print(f"Estimated Market Value: ${market_value:,.2f}")
        print(f"Confidence Level: {confidence:.1f}%")
        print(f"Recommendation: {recommendation}")
        print("\nRECOMMENDATIONS:")
        for rec in recommendations:
            print(f"• {rec}")
except Exception as e:
        print(f"Error in prediction: {e}")
        print("Please check your inputs and try again.")

import requests
from datetime import datetime
import json

def get_real_time_weather(location):
    API_KEY = "your_api_key_here"

    try:
        geo_url = f"http://api.openweathermap.org/geo/1.0/direct?q={location},IN&limit=1&appid={API_KEY}"
        geo_response = requests.get(geo_url)
        geo_data = geo_response.json()

        if not geo_data:
            print(f"Location '{location}' not found. Using default weather data.")
            return None

        lat = geo_data[0]['lat']
        lon = geo_data[0]['lon']

        weather_url = f"https://api.openweathermap.org/data/2.5/weather?lat={lat}&lon={lon}&appid={API_KEY}&units=metric"
        response = requests.get(weather_url)
        data = response.json()

        if response.status_code == 200:
            return {
                'temperature': data['main']['temp'],
                'humidity': data['main']['humidity'],
                'rainfall': data.get('rain', {}).get('1h', 0) if 'rain' in data else 0,
                'description': data['weather'][0]['description']
            }
        else:
            print("Weather API error. Using default data.")
            return None

    except Exception as e:
        print(f"Weather API error: {e}. Using default data.")
        return None

def get_crop_market_price(crop_type):
    price_data = {
        'rice': 0.40, 'wheat': 0.35, 'maize': 0.30, 'sugarcane': 0.05,
        'cotton': 1.20, 'soybean': 0.45, 'groundnut': 0.80, 'pulses': 0.60
    }

    crop_lower = crop_type.lower()
    for key in price_data:
        if key in crop_lower:
            return price_data[key]

    return 0.35

def get_user_input_and_predict():
    print("\n" + "="*60)
    print("CROP YIELD PREDICTION SYSTEM WITH REAL-TIME DATA")
    print("="*60)

    crop_type = input("Enter Crop Type (e.g., Rice, Wheat, Maize): ").strip()
    farm_area = float(input("Enter Farm Area (hectares): "))
    location = input("Enter Location/State: ").strip()
    growing_season = input("Enter Growing Season (Kharif/Rabi/Whole Year): ").strip()

    print(f"\nFetching real-time weather data for {location}...")
    weather_data = get_real_time_weather(location)

    if weather_data:
        expected_rainfall = weather_data['rainfall'] * 24 * 30
        avg_temperature = weather_data['temperature']
        print(f"Current temperature in {location}: {avg_temperature}°C")
        print(f"Recent rainfall: {weather_data['rainfall']} mm/h")
        print(f"Weather condition: {weather_data['description']}")
    else:
        expected_rainfall = float(input("Enter Expected Rainfall (mm): "))
        avg_temperature = float(input("Enter Average Temperature (°C): "))

    try:
        input_data = X.mean().to_frame().T

        input_data['Area'] = farm_area

        if crop_type in label_encoders['Crop'].classes_:
            input_data['Crop'] = label_encoders['Crop'].transform([crop_type])[0]

        if location in label_encoders['State'].classes_:
            input_data['State'] = label_encoders['State'].transform([location])[0]
        else:
            if crop_type in df['Crop'].values:
                common_state = df[df['Crop'] == crop_type]['State'].mode()
                if len(common_state) > 0:
                    input_data['State'] = label_encoders['State'].transform([common_state[0]])[0]

        input_data['Annual_Rainfall'] = expected_rainfall

        temp_factor = avg_temperature / 25.0
        input_data['Fertilizer'] = input_data['Fertilizer'] * temp_factor

        predicted_yield, recommendation = predict_yield_and_recommend(rf, input_data, crop_type)

        if crop_type in df['Crop'].values:
            crop_data = df[df['Crop'] == crop_type]
            crop_avg_yield = crop_data['Yield'].mean()
            crop_max_yield = crop_data['Yield'].max()
            yield_ratio = predicted_yield / crop_avg_yield
            confidence = min(100, max(0, yield_ratio * 80))
        else:
            crop_avg_yield = df['Yield'].mean()
            crop_max_yield = df['Yield'].max()
            confidence = 70

        market_price = get_crop_market_price(crop_type)
        estimated_production = farm_area * predicted_yield
        market_value = estimated_production * market_price

        recommendations = generate_recommendations(crop_type, predicted_yield, crop_avg_yield,
                                                 expected_rainfall, avg_temperature, growing_season)

        display_results(crop_type, location, growing_season, farm_area, predicted_yield,
                       estimated_production, market_value, confidence, recommendation, recommendations)

        create_comprehensive_visualization(crop_type, predicted_yield, crop_avg_yield, crop_max_yield,
                                         estimated_production, market_value, confidence)

    except Exception as e:
        print(f"Error in prediction: {e}")

def generate_recommendations(crop_type, predicted_yield, crop_avg_yield, rainfall, temperature, season):
    recommendations = []

    yield_ratio = predicted_yield / crop_avg_yield if crop_avg_yield > 0 else 1
    if yield_ratio >= 1.2:
        recommendations.append("✓ Excellent yield potential - optimal conditions")
    elif yield_ratio >= 0.8:
        recommendations.append("✓ Good yield potential - favorable conditions")
    else:
        recommendations.append("⚠ Below average yield potential - consider improvements")

    if rainfall < 500:
        recommendations.append("⚠ Low rainfall expected - implement irrigation system")
    elif rainfall > 1500:
        recommendations.append("⚠ High rainfall expected - ensure proper drainage and flood protection")
    else:
        recommendations.append("✓ Adequate rainfall expected - good for most crops")

    if temperature < 15:
        recommendations.append("⚠ Cool temperatures - consider cold-tolerant varieties or greenhouse")
    elif temperature > 35:
        recommendations.append("⚠ High temperatures - provide shade and increase watering frequency")
    else:
        recommendations.append("✓ Optimal temperature range for growth")

    season_lower = season.lower()
    if 'kharif' in season_lower:
        recommendations.append("✓ Kharif season - ideal for monsoon crops like rice, cotton")
    elif 'rabi' in season_lower:
        recommendations.append("✓ Rabi season - good for wheat, barley, pulses")

    crop_lower = crop_type.lower()
    if 'rice' in crop_lower:
        recommendations.append("✓ Rice - ensure good water management and paddy field preparation")
    elif 'wheat' in crop_lower:
        recommendations.append("✓ Wheat - monitor for rust diseases and ensure proper nitrogen application")

    return recommendations

def display_results(crop_type, location, season, area, yield_val, production, market_val, confidence, recommendation, recommendations):
    print("\n" + "="*60)
    print("PREDICTION RESULTS")
    print("="*60)
    print(f"Crop: {crop_type}")
    print(f"Location: {location}")
    print(f"Season: {season}")
    print(f"Farm Area: {area} hectares")
    print(f"\nExpected Yield: {yield_val:.2f} kg/ha")
    print(f"Total Production: {production:,.2f} kg")
    print(f"Estimated Market Value: ${market_val:,.2f}")
    print(f"Confidence Level: {confidence:.1f}%")
    print(f"Recommendation: {recommendation}")

    print("\nRECOMMENDATIONS:")
    for i, rec in enumerate(recommendations, 1):
        print(f"{i}. {rec}")

def create_comprehensive_visualization(crop_type, predicted_yield, avg_yield, max_yield, production, market_value, confidence):
    fig = plt.figure(figsize=(20, 12))

    plt.subplot(2, 3, 1)
    yields = [predicted_yield, avg_yield, max_yield]
    labels = ['Predicted', 'Average', 'Maximum']
    colors = ['#2E86AB', '#A23B72', '#F18F01']
    bars = plt.bar(labels, yields, color=colors, alpha=0.8)
    plt.ylabel('Yield (kg/ha)')
    plt.title(f'Yield Comparison for {crop_type}')
    for bar, yield_val in zip(bars, yields):
        plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 5,
                f'{yield_val:.1f}', ha='center', va='bottom')

    plt.subplot(2, 3, 2)
    theta = np.linspace(0, np.pi, 100)
    r = np.linspace(0, 100, 100)
    plt.polar(theta, r, color='lightgray', alpha=0.5)
    confidence_angle = (confidence / 100) * np.pi
    plt.polar([0, confidence_angle], [0, confidence], linewidth=10, color='#2E86AB')
    plt.polar(confidence_angle, confidence, 'o', markersize=15, color='#2E86AB')
    plt.title(f'Confidence Level: {confidence:.1f}%', pad=20)
    plt.yticks([0, 25, 50, 75, 100], ['0%', '25%', '50%', '75%', '100%'])
    plt.xticks([])

    plt.subplot(2, 3, 3)
    sizes = [production, market_value]
    labels = [f'Production\n{production:,.0f} kg', f'Market Value\n${market_value:,.0f}']
    colors = ['#A23B72', '#F18F01']
    plt.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%', startangle=90)
    plt.axis('equal')
    plt.title('Production & Market Value')

    plt.subplot(2, 3, 4)
    factors = ['Yield Potential', 'Weather Conditions', 'Market Outlook', 'Season Fit']
    scores = [min(100, (predicted_yield/avg_yield)*80), 75, 70, 85]
    colors = ['#2E86AB' if score >= 70 else '#A23B72' for score in scores]
    y_pos = np.arange(len(factors))
    bars = plt.barh(y_pos, scores, color=colors, alpha=0.8)
    plt.yticks(y_pos, factors)
    plt.xlabel('Score (%)')
    plt.title('Crop Suitability Scorecard')
    for bar, score in zip(bars, scores):
        plt.text(bar.get_width() + 1, bar.get_y() + bar.get_height()/2,
                f'{score:.0f}%', va='center')

    plt.subplot(2, 3, 5)
    if crop_type in df['Crop'].values:
        crop_data = df[df['Crop'] == crop_type]
        seasonal_yield = crop_data.groupby('Season')['Yield'].mean()
        if not seasonal_yield.empty:
            seasonal_yield.plot(kind='bar', color='#2E86AB', alpha=0.8)
            plt.title('Average Yield by Season')
            plt.ylabel('Yield (kg/ha)')
            plt.xticks(rotation=45)

    plt.subplot(2, 3, 6)
    risks = ['Weather', 'Pests', 'Market', 'Labor']
    risk_levels = [30, 45, 25, 35]
    colors = ['green' if x < 33 else 'orange' if x < 66 else 'red' for x in risk_levels]
    plt.bar(risks, risk_levels, color=colors, alpha=0.8)
    plt.ylim(0, 100)
    plt.ylabel('Risk Level (%)')
    plt.title('Risk Assessment')
    for i, risk in enumerate(risk_levels):
        plt.text(i, risk + 2, f'{risk}%', ha='center')

    plt.suptitle(f'CROP YIELD PREDICTION ANALYSIS: {crop_type.upper()}', fontsize=16, fontweight='bold')
    plt.tight_layout()
    plt.show()

get_user_input_and_predict()